------------------------------------------------------------------
00 : Template 기본개념
------------------------------------------------------------------
함수오버로딩 : 사용자 입장에서 하나인것처럼 사용자
           단점, 유사코드 증가 -> 전처리 매크로 사용

#define MAKE_SQUARE(T) \
T square(T a)          \
{                      \
    return a*a;        \
}                      \

MAKE_SQUARE(int)
MAKE_SQUARE(double)

int main()
{
    square(3);
    square(3.3)
}

------------------------------------------------------------------
01 : 위의 전처리 매크로를 컴파일러에게 맡겨보자.
------------------------------------------------------------------
틀을 만들거고, 타입을 하나 받을거다
타입이 결정되면 아래 모양의 틀을 이용해서 오버로딩 코드를 생성하겠다.
즉, 컴파일 타임에 해당 함수를 사용한 데이터 타입만큼의 함수오버로딩이 이루어진다.

template<typename T> // template<class T> 둘의 차이점은 없다.
T square(T a)
{
    return a*a;
}

int main()
{
    square(3);  // square<int>(3);
    square(3.3);// square<double>(3.3);
}

------------------------------------------------------------------
02 : Template의 필요성
------------------------------------------------------------------
데이터 타입에 맞는 최적화된 클래스를 사용하게 끔 설계할 수 있다.

------------------------------------------------------------------